<!DOCTYPE html>

<html>

<head>
<style>
	body {
		background-color: #fff;
		color: #111;
		margin: 0px;
		overflow: hidden;
		font-family: Monospace;
		font-size: 20px;
		position: absolute;
	}
	#info {
		position: absolute;
		top: 0px; width: 100%;

		padding: 5px;
		text-align: center;
		color: #ffff00
	}
	strong {color:red}


</style>
</head>

<body>
	<div id="info">
	<p>HW5</p>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
	<script src="https://jyunming-chen.github.io/tutsplus/js/OrbitControls.js">
	</script>
	<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>



<script>
var camera, scene, renderer, mesh, controls;

var box = new THREE.Object3D();
var toycar = new THREE.Object3D();
var pos = new THREE.Vector3();


init();
animate();

function unitize (object, targetSize) {

	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);

	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );

	// uniform scaling according to objSize
	var objSize = findMax (size);
	var scaleSet = targetSize/objSize;

	var theObject =  new THREE.Object3D();
	theObject.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);

	return theObject;


	// helper function
	function findMax(v) {
		if (v.x > v.y) {
			return v.x > v.z ? v.x : v.z;
		} else { // v.y > v.x
			return v.y > v.z ? v.y : v.z;
		}
	}

}
function init() {

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.z = 250;
  camera.position.y = 50;

  var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
  scene.add(gridXZ);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);


  controls = new THREE.OrbitControls(camera, renderer.domElement);

  controls.enableKeys = false;

  document.body.appendChild(renderer.domElement);
  ////////////////////////////////////////////////////////////////////////
	var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
	scene.add( directionalLight );

	var texture = new THREE.TextureLoader().load( 'https://i.imgur.com/rjEHocK.png' );

// immediately use the texture for material creation
	var material = new THREE.MeshBasicMaterial( { map: texture,color:0xffead1 } );
	var desk = new THREE.Object3D();
	var deskMesh1 = new THREE.Mesh(new THREE.BoxGeometry(80,2,50),material);
	desk.add(deskMesh1);
	var deskMesh2 = new THREE.Mesh(new THREE.BoxGeometry(2,40,50),material);
	deskMesh2.position.set(-39,-20,0);
	desk.add(deskMesh2);
	var deskMesh3 = deskMesh2.clone();
	desk.add(deskMesh3);
	deskMesh3.position.x =39;
	var deskMesh4 = deskMesh2.clone();
	deskMesh4.position.x =11;
	desk.add(deskMesh4);
	var deskMesh5 = new THREE.Mesh(new THREE.BoxGeometry(80,40,1),material);
	deskMesh5.position.set(0,-19,-24);
	desk.add(deskMesh5);
	scene.add(desk);
	desk.position.y =39;
	////////////////////////////////////////////////////////////////////////
	var Lamp = new THREE.Object3D();
	Lamp = makeTableLamp();
	//Lamp.position.set(0,0,0);
	//scene.add(Lamp);





}

function makeTableLamp(){

	var theOb = new THREE.Object3D();
	var onProgress = function(xhr) {
		if (xhr.lengthComputable) {
			var percentComplete = xhr.loaded / xhr.total * 100;
			console.log(Math.round(percentComplete, 2) + '% downloaded');
		}
	};
	var onError = function(xhr) {};
	var mtlLoader = new THREE.MTLLoader();
	mtlLoader.setPath('table lamp/');
	mtlLoader.load('table lamp.mtl', function(materials) {

		materials.preload();

		var objLoader = new THREE.OBJLoader();
		objLoader.setMaterials(materials);
		objLoader.setPath('table lamp/');
		objLoader.load('table lamp.obj', function(object) {

			theObject =  unitize (object, 30);
			theOb.add(theObject);
			object.traverse (
				function(mesh) {
					if (mesh instanceof THREE.Mesh) {
						mesh.material.side = THREE.DoubleSide;
					}
				});
		}, onProgress, onError);
	});
	return theOb;
}
function animate() {

  controls.update();
	requestAnimationFrame(animate);
  render();
}

function render() {

  renderer.render(scene, camera);
}

</script>
</body>

</html>
